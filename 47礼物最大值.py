"""
难度:中等 (动态规划)
在一个 m*n 的棋盘的每一格都放有一个礼物，
每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，
并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，
请计算你最多能拿到多少价值的礼物？

示例 1:

输入: 
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
输出: 12
解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物
 

提示：

0 < grid.length <= 200
0 < grid[0].length <= 200
"""

def maxValue(self, grid: list[list[int]]) -> int:
    """
    m行*n列的格子
    0.从0,0 开始到 [m-1,n-1]
    1.每个格子,只能向下或右移动

    递归:
    1.向右,向下
    2.只能向右
    3.只能向下
    递归计算right,down之和, 矩阵过大时会超时!!!


    移动次数:  (m+n -1)
    
    每一个格子可以是起点或终点.
    如果该格子坐标(i,j)是终点: i == m-1, j == n - 1

    比较从起点开始走之和 与终点开始走之和
    设f(i,j) 为从0,0 走到坐标i,j 时的最大值,
    每次只能移动右或下, 走到坐标i,j时, 只需要知道比较走到该坐标左一坐标,上一坐标的最大值
    f(i,j) = grid(i,j) + max(f(i,j-1), f(i-1, j))
    四种情况最大值:
    i=0,j=0: grid(0,0)
    i=0, j>0 第1行的所有坐标,上一个最大值只在左边: grid(0,j) += grid(0,j-1)
    j=0, i>0 第1列, 上一个最大值只在上边: grid(i,0) += grid(i-1,0)
    i>0,j>0: grid(i,j) += grid(i,j) + max(grid(i,j-1),grid(i-1,j))
    """
    i,j =0,0
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if i == 0 and j == 0: continue
            if i == 0:grid[i][j] += grid[i][j-1] 
            elif j == 0: grid[i][j] += grid[i-1][j]
            else:grid[i][j] = grid[i][j] + max(grid[i-1][j],grid[i][j-1])
    return grid[-1][-1]