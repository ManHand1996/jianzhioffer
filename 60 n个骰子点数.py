class Solution:
    def dicesProbability(self, n: int) -> list[float]:
        """
        推导, 设f(n,x) 表示 n个骰子,出现值x的可能性
        n个骰子某个值x的出现的可能性与 n-1个骰子的x-1值相关
        所以:
        n-1个骰子的某个值x出现的可能性与 n个骰子的x+1, x+2 ... x+6的可能性相关
        由于值是递增的,并且每个骰子值的范围为[1,6]
        所以 遍历f(n-1)后将对应的值x+1...x+6 的所有可能累加就可以得出结果

        n = 2时

        f(1): 1,2,3,4,5,6
        f(2): 
        [1,1], [1,2], [1,3] [1,4] [1,5] [1,6] 与 f(1,1) 相关的可能性
        [2,2], [2,3], [2,4], [2,5], [2,6] 与 f(1,2) 相关的可能性
        [3,3], [3,4], [3,5], [3,6]
        [4,4], [4,5], [4,6]
        [5,5], [4,6]
        [6,6]
        
        每遍历一轮 f(n-1,x) 就可以计算 x+1...x+6 的可能性
        在加上前依次遍历的x+1..x+6的可能性
        
        
        可以看作第一位为第n个骰子(1/6), 剩余的为n-1个骰子的值x的可能性
        
        f(1): 1/6,1/6, 1/6, 1/6, 1/6, 1/6 [1,6]
            f(1,1)与 f(2,2), f(2,3) f(2,4).. f(2,6) 相关
        f(2): 1/6 * f(1,1)  1/6 * f(1,2) [2,12]

        """
        
        p = 1/6 # p = fractions.Fraction(1,6)
        # 需要保存n-1个骰子的所有值的可能性
        r = [p] * 6
        for i in range(2,n+1):
            j = 0
            tmp = [0] * (5*i+1)
            while j < len(r):
                for k in range(6):
                    tmp[j+k] += r[j] * p
                j += 1
            r = tmp
        return r
            # return [round(i.numerator/i.denominator,5) for i in r]
            