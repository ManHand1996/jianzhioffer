def lastRemaining(n: int, m: int) -> int:
    """
    约瑟夫环问题
    0,n-1的值 n个数,删除第m个(从下个数字开始从新计算),直到剩余一个数x,问这个数是多少
    * 转换成编号更容易理解
    0,n-1的值,转换成 1,n的值, 共n个
    将这些值从1开始编号,到n, 转换成为在长度为n中,剩余的数是第x个数
    每删除一个则从下一个开始编号(新的编号与旧的编号刚好相差m)
    当m=3, n=5时
    左边为值, 右边为编号, 
    由于删除后,与删除前, 所求的第x个数,是一样的,只是编号有所不同
    设解为f(n)表示:编号,第x个
    
    f(5) 0,1,2,3,4 (1,2,3,4,5) 
    f(4) 0,1,3,4 (3,4, 1,2)
    f(3) 1,3,4 (1,2,3)
    f(2) 1,3 (1,2)
    f(1) 3 (1)
    新的编号与旧的编号(这时是同一个值)相差m
    f(n,m) == f(n-1,m) + m
    但由于 f(n-1,m) + m 可能会大于 n(长度)
    所以需要减去长度n, 直到f(n-1,m) + m 小于等于 长度 n
    
    f(n,m) = f(n-1,m) % n
    即取模, 当取模值仍然大于长度n时,减去n即可
    要求f(n) 需要知道f(n-1).. f(n-1) .. f(1)
    f(1) 恒定等于 = 1
    所以从f(1) 开始计算知道f(n)即可
    """ 
    # 容易理解:
    # x 表示编号
    # i 表示长度
    # f(i) = f(i-1) + m % i
    # if f(i) == 0: f(i) += i
    x = 1
    for i in range(1, n+1):
        x = (x + m) % i
        if x == 0:
            x += i
    return x - 1
    # i 表示长度
    # x 表示值
    # x = 0
    # 这时值范围一定是 0,i-1 ( 取模结果不会比被取模数大)
    # for i in range(2, n+1):
    #     x = (x+m)% i