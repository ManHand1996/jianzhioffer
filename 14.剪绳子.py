"""
难度:中等 (动态规划)
给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），
每段绳子的长度记为 k[0],k[1]...k[m - 1] 。请问 k[0]*k[1]*...*k[m - 1] 可能的最大乘积是多少？
例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

 

示例 1：

输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1
示例 2:

输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36
 

提示：

2 <= n <= 1000
"""

def cuttingRope(self, n: int) -> int:
    """
    1.
    遍历各种切法(2,n) 找出最大值, 每种切法的长度可能相同
    暴力方法,最慢.
    
    2.
    分情况讨论, 找出切割段数最优解.
    当 n < 3时, 乘积最大为 max(n-1,1)
    当 n = 4, 有 2*2 , 3*1 , 
    当 n = 5, 有 3*2
    当 n = 7  2*2*3
    当 n = 8  2*3*3
    ...
    n = 36  3**12 
    切分为3的倍数 可以得到乘积最大值.
    p = n % 3, 余数
    q = n // 3, 整数部分(有多少个3)
    当 p == 0:  3**p
    当 p == 1: 3**(p-1) * 2
    当 p == 2: 3**(p-1) * 4

    结果对 k=1000000007取模, 如果要求值在不超过int32范围内则需要额外处理(在Python中不需要)
    根据 x*y % k = (x % k * y % k ) % k
    循环求余数,
    在本题中:
    x = 3, 有 y个x [1,y] x^y

    循环 y次
    rem = 1
    rem = rem * x % k

    快速求幂:
    在本题中:
    x = 3, 有 y个x [1,y] x^y
    y为偶数: x^y % k = x % k * x%k * ... *y次 = (x^2 % k)^(y//2) % k
    y为奇数: x^y % k = x % k * x%k *... * y-1次 * x%y =   x*(x^2 % k)^(y//2) % k
    需要执行 y // 2 + 1 次
    当y = 2
    if y % 2:
        r = (r *x )%k
    x = x**2 % k
    y //= 2 
    """
    
    # start 自己的解法:
    if n <= 3:
        return max(n-1,1)

    x = 1
    for s in range(2,n+1):
        q = n % s
        p = n // s
        t = p**(s-q) * (p+1)**q
        
        x = t if t > x else x
    return x % (10**9+7)
    # end
    
    
    k = 1000000007
    # 循环求余(N) 本题中N为需要乘多次3
    def modInt(x,p,k):
        rem = 1
        for _ in range(p):
            rem = rem*x % k
        return rem
    # 快速求余 (log2N)
    def modInt2(x,p, k):
        rem = 1
        while p > 0:
            if p % 2:
                rem = (rem*x) % k
            x = x**2 % k
            p = p//2
        return rem

    if n <= 3:
        return max(n-1,1)
    p = n // 3 - 1 # 留一位与余数位进行判断乘积最大值
    q = n % 3  # 余数位
    rem = modInt2(3,p,k)
    if q == 0:return (rem*3) % k # 剩余一个3, 余数为0
    if q == 1: return (rem*4) % k # 剩余一个3, 余数为1, 最大乘积应为2*2
    return rem*6 % k # 剩余一个3, 余数2 最大乘积为 2*3

    